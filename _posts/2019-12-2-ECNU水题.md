### 1.章鱼王

* [题目地址](https://acm.ecnu.edu.cn/problem/3296/ )

```c
#include<stdio.h> 
using namespace std;
int main(){
	int n;
	int i=0;
	scanf("%d",&n);
	int num[n];
	while(n--){
		scanf("%d",&num[i++]);
	}
	int j=0;
	while(i--){
		printf("%d\n",num[j++]/3);
	}
}
```



### 2.拥塞的城市

* [题目地址]( https://acm.ecnu.edu.cn/problem/2145/ )

```c
//原始思路，用数组存入随着偏离中心每楼层数 运行时间3.0s超时
#include<stdio.h>
using namespace std;
int main(){
	int T;
	int sum=0;
	int level;
	scanf("%d",&T);
	while(T--){
        int a[level];
		a[1]=4;
		int j=2;
		for(;j<=level;j++){
			a[j]=a[j-1]+8;
		}
		int index=1;
		while(level>0){
			sum+=(level*(4+8*index));
			level--;
		}
        printf("%d\n",sum);
		sum=0;//因为sum为全局作用域
	}
}
//改进，不用数字，直接计算 0.05s
#include<stdio.h>
using namespace std;
int main(){
	int T;
	int level;
	scanf("%d",&T);
    while(T--){
        int sum=0;
        scanf("%d",&level);
        sum+=level*4;
        int index=1;
        while(level>1){
            sum+=(--level)*(4+(index++)*8);
        }
        printf("%d\n",sum);
          
    }
```

### 3.求100-200素数

```c
#include<iostream> 
#include<math.h>
using namespace std;
bool isPrime(int num){
	int i=2;
	for(;i<=(int)sqrt(num);i++){
		if(num%i==0){
			return false;
		}
	}
	return true;
}
int main(){
	int j=100;
	for(;j<=200;j++){
		if(isPrime(j)){
			cout<<j<<" ";
		}
	}
}
```

### 4.母牛生小牛问题

* [题目地址](https://acm.ecnu.edu.cn/problem/1030/)

```c
#include<iostream> 
using namespace std;
int main(){
	int a[51];//要大于50后面有测试点求第50年
	int i=4;
	a[1]=1;
	a[2]=1;
	a[3]=1;
	for(;i<=50;i++){//这里等于，太菜了！
	   a[i]=a[i-1]+a[i-3];
	}
	while(1){
		int years=0;
		cin>>years;
		if(years==0) break;
		cout<<a[years]<<endl;
	}
}
```

### 5.已知各点坐标求面积

* [题目地址](https://acm.ecnu.edu.cn/problem/1127/)

  本质上是数学题目，为什么题目按逆时针给出点的坐标，目的是让你考虑用有向面积的方法就是用向量的方法表示各点，这里就有公式了，如下图所示，具体证明不懂。。。。

  ![](\images\有向面积公式.png)

```c
#include<iostream> 
using namespace std;
struct P{
	int x;
	int y;
}p[101]; 
int area(int a){
	int b=a-1;
    //可以理解上图的A点是p[0],B点是p[b],C点是p[a],就是AB向量与AC向量的叉积
	return (p[b].x-p[0].x)*(p[a].y-p[0].y)-(p[b].y-p[0].y)*(p[a].x-p[0].x);
}
int main(){
	int n;	
	while(cin>>n){
		if(n==0) break;
		int j=0;
		for(;j<n;j++){
			cin>>p[j].x;
			cin>>p[j].y;
		}
		int k=2;
		double sum=0;
		for(;k<n;k++){
			sum+=1.0/2.0*area(k);//公式，把多边形每块三角形相加
		}
		printf("%.1lf",sum);
	}
}
########################################################

```

* 第二种方法(目前而言错误)

  第二种方法，我自己考虑的，可以求出在四轴方向延伸最远的点，然后形成矩形，得到四点即角坐标并计算与多边形两点边的距离(两点确定一条边)，从而计算点与边直线距离(高)，最终计算出三角形面积，用形成的矩形减去把所有三角面积和就是多边形面积。

  ![](\images\错误集锦\多边形求面积思路.png)

### 6.回文串

* [题目地址](https://acm.ecnu.edu.cn/problem/3686/)

  题目虽然简单，但是我没写出来，菜....

  ```c
  //采用的是从两边向内策略，比较两边数字大小，小的一边加上后一位，相等则两者靠拢
  #include<iostream>
  #include<vector>
  using namespace std;
  vector<long long> v(1000010);//如果用int的话，可能相加会超出int范围，会卡在66测试点
  int main(){
  	int n;
  	cin>>n;
  	for(int j=0;j<n;j++){
  		cin>>v[j];
  	}
  	int cnt=0;
  	int i=0,j=n-1;
  	while(i<j){//注意这里结束条件，只采用了两个指针，而不是我的四个指针
  		long long left=v[i]+v[i+1];
  		long long right=v[j]+v[j-1];
  		if(v[i]==v[j]){
  			i++;
  			j--;
  		}else if(v[i]<v[j]){
  		    v[i+1]=left;
  			i++;
  			cnt++;	
  		}else if(v[i]>v[j]){
  			v[j-1]=right;
  			j--;
  			cnt++;
  		}
  	}
  	cout<<cnt<<endl;
  }
  ```

  