## 2. ECNU水题-2

### 1.找数

* [题目地址](https://acm.ecnu.edu.cn/problem/3290/)

```c
//超时我的程序，给我思路，一般大于int的数不要设计计算，否则很慢
#include<bits/stdc++.h>
using namespace std;

bool isUpNum(long long num) {
	stack<int> s;
	while(num>0){
		int n;
		n=num%10;
		num/=10;
		if(s.empty()){
			s.push(n);
		}else if(s.top()>n){
			return false;
		}else if(s.top()<=n){
			s.push(n);
		}
	}
	if(num==0){
		return true;
	}
}
int main(){
	int T;
	cin>>T;
	int j=T;
	long long num;
	while(T--){
		cin>>num;
		while(!isUpNum(num)){
			num++;
		}
		cout<<"case #"<<j-T-1<<":"<<endl;
		cout<<num<<endl;
	}
}
//别人思路及代码 https://blog.csdn.net/lecholin/article/details/77916349
	最自然的想法是，通过扫描s[i] < s[i+1]找到上升点，然后对上升点前的s[i-1]+1，后面全部填0。但是要考虑到s[i-1]+1后可能会破坏前面的非上升序列，因此还要将前面的元素考虑进来。

采取的办法是，在扫描上升点的同时，维护经过的最小数字及位置，找到上升点后，判断s[i-1]+1和该最小数字的大小，如果s[i-1]+1更小，那就在后面填0即可，否则要对最小数字+1，并在其后全填0。（实质是让填0前的那个数字保持最小）
例子：7400920的上升点在第二个0和9之间，如果变成7101000不满足“非上升”，但是变成7410000则满足。
#include <iostream>
using namespace std;
int main()
{
    int kase;
    cin >> kase;
    string s;
    for(int t = 0; t < kase; ++t)
    {
        cin >> s;
        int min_num = 10, min_pos = 0; //最小数字及所在小标
        for (int i = 0; i < s.size()-1; ++i)
        {
            if (s[i] < s[i+1]) //出现上升
            {
                int tmp = s[i] - '0' + 1, pos = (tmp>min_num)?min_pos:i; //pos为更新的位置
                //要更新的数字加1，后面全填0
                s[pos]++; 
                for(int j = pos + 1; j < s.size(); ++j)
                    s[j] = '0';
                break;
            }
            else if (s[i]-'0' < min_num) //维护经过的最小数字
            {
                min_num = s[i] - '0';
                min_pos = i;
            }
        }
        cout << "case #" << t << ':' << endl;
        cout << s << endl;
    }
    return 0;
}
```

### 2.四位数加法

* [题目地址](https://acm.ecnu.edu.cn/problem/3444/)

```C
#include<bits/stdc++.h>
using namespace std;
//求分子分母最大公倍数
long long getMaxCommonMultiple(long long mother,long long son){
	long long min ;
	if(mother>son){
		min=son;
	}else if(mother<son){
		min=mother;
	}else{
		return son;
	}
    //缺考虑了
	if(son%mother==0){
		return mother;
	}
	long long i;
	for(i=(long long)sqrt(min);i>0;i--){
		if(mother%i==0&&son%i==0){
			return i;
		}
	}
	//如果i==1说明没有公倍数，提示函数调用者即可
	if(i==1){
		return 1;
	}
	
}
long long FractionSum(int aaaabbbb, int ccccdddd) { 
   int a,b,c,d;
   long long son,mother;
   a=aaaabbbb/10000;
   b=aaaabbbb%10000;
   c=ccccdddd/10000;
   d=ccccdddd%10000;
   mother=b*d;
   son=a*d+c*b;
   long long i=getMaxCommonMultiple(mother,son);
   if(i==1){
   	 return son*100000000+mother;
   }else{
   	 son/=i;
   	 mother/=i;
   	 return son*100000000+mother;
   }

}
int main(){
    int a, b, c, d;
    long long r;
    scanf("%d%d%d%d", &a, &b, &c, &d);
    r = FractionSum(a * 10000 + b, c * 10000 + d);

    printf("%d/%d+%d/%d=%lld/%lld.\n", a, b, c, d,
           r / 100000000, r % 100000000);
    return 0;
}
```

### 3.进制转换

* [题目地址](https://acm.ecnu.edu.cn/problem/3679/)

```c
//1.初始思路，超时。。。。
#include<bits/stdc++.h>
using namespace std;

bool isTrue(long long num,int ary,int m){
	int arr[200];
	int i=0,cnt=0;
	do{
	   arr[i]=num%ary;
	   num/=ary;
	   i++;	
	}while(num!=0);
	for(int j=0;j<i;j++){
		if(arr[j]==0){
			cnt++;
		}else{
			break;
		}
	}
	if(cnt==m){
		return true;
	}else{
		return false;
	}
}
int main(){
	long long l,r;
	int k,m,T; 
	cin>>T;
	while(T--){
		cin>>l>>r>>k>>m;
		int cnt=0;
		for(;l<r;l++){
			if(isTrue(l,k,m)){
				cnt++;
			}
		}
		cout<<cnt<<endl; 
	}
} 
//2.更新、中途break 也超时。。。
#include<bits/stdc++.h>
using namespace std;
bool isTrue(long long num,int ary,int m){
	for(int i=0;i<m;i++){
		if(num%ary==0&&num>0){
			num/=ary;
		}else{
			return false;
		}
	}
	if(num%ary!=0){
		return true;
	}
}
int main(){
	long long l,r;
	int k,m,T; 
	cin>>T;
	while(T--){
		cin>>l>>r>>k>>m;
		int cnt=0;
		for(;l<r;l++){
			if(isTrue(l,k,m)){
				cnt++;
			}
		}
		cout<<cnt<<endl; 
	}
} 
//大佬思路
题目要求的时在区间范围内的m进制后有k个零的数有多少，很容易想到如果一个数的m进制后有k个零，就一定能被m^k整除，而在含k个零中，一定存在含k+1个零的（含k+1个零就意味着一定含k个零），在1，2，3....x中，能被m^k整除的有⌊x/m^k⌋个，所以只含k个零的个数有ansx = ⌊x/m^k⌋-⌊x/m^k+1⌋，区间的话就是ansr - ansl-1 注意是l-1
但是有个问题，就是直接计算mk 会溢出的问题，而且又不能取模，根据式子，就要用到除法，如果溢出了，相除肯定变成了0（据说long double好像也行，我没试过）
#include<bits/stdc++.h>
using namespace std;

int main(){
	long long l,r;
	int k,m,T; 
	cin>>T;
	while(T--){
		cin>>l>>r>>k>>m;
		l--;//这步为什么 
		long long rf=r,lf=l;
		for(int i=0;i<m;i++){
			rf=(long long)(rf/k);
			lf=(long long)(lf/k);
		}
		long long rfs=(long long)(rf/k);
		long long lfs=(long long)(lf/k);
		cout<<rf-lf-rfs+lfs<<endl;
	}
}
```

### 4.斐波那契求和

* [题目地址](https://acm.ecnu.edu.cn/problem/2536/)

```c
#include<bits/stdc++.h>
using namespace std;

struct Fraction{
	unsigned long long up,down;
};
long long gcd(long long a,long long b){
	if(b==0) return a;
	else return gcd(b,a%b);
	
}
Fraction reduce(Fraction c){
	//求出两个数最大公约数
	long long maxC = gcd(c.down,c.up);
	c.down/=maxC;
	c.up/=maxC;
	return c;
}
//分数加法
Fraction add(Fraction a,Fraction b){
	Fraction c;
	c.down=a.down*b.down;
	c.up=a.up*b.down+b.up*a.down;
	return reduce(c);//约分 
}
int main(){
	int T;
	cin>>T;
	while(T--){
	int N;
	cin>>N;
//	N=N+1;//不知道为什么。。。整体少加了一位 
	unsigned long long f[N+2];
	f[1]=1,f[2]=1;
	for(int i=3;i<=N+2;i++){
		f[i]=f[i-1]+f[i-2];
	 }
	Fraction fraction[N+1];//用来存分数
//	cout<<f[3]<<f[1]+f[2]<<endl;
//	f[3]%=10;//在N未加1时，为什么这里的f[3]是52... 
//	cout<<f[3]<<f[1]+f[2]<<endl;
	for(int i=1;i<=N;i++){
		fraction[i].up=f[i+2];
		fraction[i].down=f[i+1];
	}
	Fraction result;
	result=fraction[1];
//	 cout<<result.up<<"/"<<result.down; 
	 for(int i=2;i<=N;i++){
		result=add(result,fraction[i]);
	 }
	 cout<<result.up<<"/"<<result.down; 
	}
} 
```


$$

$$
